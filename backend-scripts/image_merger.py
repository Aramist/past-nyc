import numpy as np
import pyproj
from scipy.spatial import cKDTree as Tree


def make_groups(paired_points):
    """ Treats the set of pairs generated by SciPy's kdTree query as an equivalence
    relation on the underlying indices and generates a list of equivalence classes
    for the relation.
    """
    eq_classes = list()

    def helper_get_index(tup, group_list):
        """ Finds the list in group_list containing at least one of the elements
        of tup. This corresponds to the equivalence class that the elements of tup
        belong to.
        """
        for n, g in enumerate(group_list):
            if tup[0] in g or tup[1] in g:
                return n
        return None

    for tup in paired_points:
        idx = helper_get_index(tup, eq_classes)
        if idx is None:
            eq_classes.append({tup[0], tup[1]})
        else:
            eq_classes[idx].add(tup[0])
            eq_classes[idx].add(tup[1])
    return eq_classes


def merge_nearby_points(image_groups, thresh_distance=20):
    """ Merges points within a given distance of each other
    """

    # This line was taken from a stackoverflow post
    # I can't find the post I referenced, so no link
    # It's supposed to give me a coordinate in meters, approximately
    meter_projection = pyproj.Transformer.from_crs('epsg:4326', 'epsg:3857')

    numpy_data = np.array([
        meter_projection.transform(group.json['latitude'], group.json['longitude'])
        for group in image_groups])
    tree = Tree(numpy_data)

    pairs = tree.query_pairs(thresh_distance)
    groups = make_groups(pairs)
    # The set of all (indices to) ImageGroups that won't be merged into any others
    leftovers = set(range(len(image_groups))).difference(*groups)
    new_data = list()
    for idx in leftovers:
        new_data.append(image_groups[idx])
    for group in groups:
        idx_list = list(group)
        merged_group = image_groups[idx_list[0]].merge_many([image_groups[i] for i in idx_list[1:]])
        new_data.append(merged_group)

    return new_data

